---
title: Go 101 - HackerSpace PESUECC's Golang Workshop!
date: "2022-10-07"
tags: [go, golang, concurrency, workshop]
description: Learn Golang!
permalink: posts/{{ title | slug }}/index.html
author_name: Mentors, HackerSpace PESUECC
author_link: /members
---

> Note : Setup and Pre-requisites are a must, the mentors will NOT be helping you install go during workshop.

## Pre-requisites | Setup

For linux :

```bash
sudo rm -rf /usr/local/go && tar -C /usr/local -xzf go1.19.1.linux-amd64.tar.gz
export PATH=$PATH:/usr/local/go/bin
go version
```

If after the 3 commands above, if you get the 1.19.1 version as output, you are good to go!

If you are on Windows, download the [Go Installer](https://go.dev/dl/go1.19.1.windows-amd64.msi) and run it.

If you are on macOS, download the [Go Installer](https://go.dev/dl/go1.19.1.darwin-amd64.pkg) and run it.

### Prelude: What's Programming?

Hint: It's more than writing code. Let's go through a few bits I've shamelessly copy-pasted from "The Structure and Interpretation of Computer Programs" -

> An assault on large problems employs a succession of programs, most of which spring into existence en route.

> To appreciate programming as an intellectual activity in its own right you must turn to computer programming; you must read and write computer programs— many of them. It doesn’t matter much what the programs are about or what applications they serve. What does matter is how well they perform and how smoothly they fit with other programs in the creation of still greater programs.

> We are about to study the idea of a computational process. Computational processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract things called data. The evolution of a process is directed by a pattern of rules called a program. People create programs to direct processes. In effect, we conjure the spirits of the computer with our spells.

That's it. A computer is basically magic that runs what are known as programs - basically, spells - that we use to manipulate the electrons to do our bidding.

## What is Go? [Speaker-1]

Golang is a programming language created at Google in 2009. It was created to address a crisis - it wasn't easy enough to write applications that were fast and ran at scale.

The existing solutions to this problem - Java and C/C++ - are all languages that are relatively difficult to learn and write maintainable code in. The existing solutions had a few problems.

- Lack of readability
- Lack of static typing, and
- Lack of easy high-performance networking and parallelism (taking advantage of all the power your computer has by doing more things at once).

The folks at google, including Ken Thompson, one of the original contributors to the C Programming Language, decided that the best way to address this issue was not to monkey-patch an existing language, but instead to write a whole new language from scratch.

Arguably, this wasn't a minor undertaking, but it's a decision that paid dividends multiple times over, as Go is arguably the standard for any modern-day backend application that needs to run at scale, and with low latency.

## Why go and how it's similar to C? [Speaker-1]

The reason people and programmers love Go, apart from the cute mascot (We love the Gopher), is that it's _extremely easy_ compared to other languages that offer the features that Go offers.

The other reason, perhaps the more important one, is that Go makes it super easy to do things in Parallel. Perhaps it won't be apparent as to how easy it is right now, but doing things in Parallel is an endeavor that involves coordinating and working with the Hardware as well as the Operating System.

Go's _concurrency model_, or how it recommends you do things in parallel, makes it extremely easy for first-timers and experienced developers alike to write code that runs in parallel with ease.

## 01 - The basic syntax

## 02 - An example, rather slow one vs what we are about to do

Here's An Example of the code for the popular "FizzBuzz" Program in Go -

```go
func fizzbuzz_stdout_sequential(start, end int) {
	for i := start; i <= end; i++ {
		if i%3 == 0 {
			fmt.Print("fizz")
		}
		if i%5 == 0 {
			fmt.Print("buzz")
		}
		if i%3 != 0 && i%5 != 0 {
			fmt.Print(strconv.Itoa(i))
		}
		fmt.Println("")
	}
}
```

And here it is in C -

```c
int fizzbuzz(int start, int end) {
  for (int i = 0; i <= end; i++) {
    if (i %3 == 0) {
      printf("fizz");
    }
    if (i %5 == 0) {
      printf("buzz");
    }
    if (i % 3 != 0 && i % 5 != 0) {
      printf("%d", i);
    }
    printf("\n");
  }
}
```

Here, you can see how similar Go and C are.

## 03-More about syntax [Speaker-2]

## 04-Concurrency

### What are threads, a very naive explaination [Speaker-2]

// Explain it to a 5 year old
Before we get started with concurrency, lets quickly skim through some basics. Try to answer the below own questions.

1. What is a program?
2. What is a process?

So, in layman terms
So, in layman terms

- **Program** is a written set of instructions or syntax with some functionality which will be executed by the computer.
- **Process** is a program in execution.
- As seen in a computer, multiple processes can execute simultaneously and well that's multiprocessing.
- But the overhead and the work put on creating a process in any OS is quite heavy.
- We use **Threads** and the concept of **Multithreading** to achieve what processes and multiprocessing does but with lower overhead and much much more simplicity.
- So, What exactly is a thread?
- A **Thread** is an independent sequence of execution within a process.
- Lets take an example,
- Alice and Joe have the sunday to themselves without their chaotic kids ruining the weekend and they want to enjoy their weekend and go out on a date!
- Saturday afternoon, Alice sees that the house is a mess, so Alice needs to finish all her chores however it is not a task that can be done single-handedly. If done single-handedly, it would take her many hours. So, what can she do? She pulls up her husband and her 3 kids and divides all the chores between them to get them done parallely and well surprisingly gets them done faster and ahead of schedule and gets to enjoy a couple more hours than her Sunday.
- So now given this analogy, let us pick out certain instances and corelate them to concurrent execution and computing.
- Alice doing all the chores single-handedly - sequential execution within a single process.
- Alice dividing all the chores between her family and getting all chores done parallely faster - concurrent multithreaded execution
- Who are the key players a.k.a the threads - alice, joe and her three kids.
- And that's threads and concurrency simplified max folks!

### Go routines [Speaker-2]

<!-- This has to end with the question, how will these routines work together?
// Answer is channels -->

### Go channels [Speaker-3]

- Theory of channels, Why channels :

Let's consider a like counter...a counter in which a person can either like(+1) or dislike (-1). But before I can explain race conditions. We need to understand the von neumann cycle.

Von Neumann architechture is as so :
```
fetch->decode->execute->write

What's to note is the "fetch" of data that happens here before execution [that too, 2 steps before exec].
```

Let's consider that one thread each handles the incoming likes and dislikes. And as we only know normal variables in Go for now, we have no other choice but to have all these threads update the value in this "integer" variables called `likes`. Let's now consider 2 requests coming in, both likes at the EXACT SAME TIME. So two threads spawn at the same time and "fetch" the memory of variable `likes`. Both do a +1 to `likes` variable. and now store it back to the same memory.

WAIIIIIIIITTTT, what just happened??? we got 2 like requests but our value only went up by 1??

```go
// UNSAFE AND WRONG CODE :
func rapid_likes_sender2(likes *int, wg *sync.WaitGroup){
  defer wg.Done()
  i := 0
  for i<100{
    *likes+=1
    i++
  }
}

func unsafe_likes_counter(){
  wg := new(sync.WaitGroup)
  likes := 0;
  wg.Add(100)
  i:=1
  for i<=10{
    go rapid_likes_sender2(&likes, wg)
    go rapid_likes_sender2(&likes, wg)
    go rapid_likes_sender2(&likes, wg)
    go rapid_likes_sender2(&likes, wg)
    go rapid_likes_sender2(&likes, wg)
    go rapid_likes_sender2(&likes, wg)
    go rapid_likes_sender2(&likes, wg)
    go rapid_likes_sender2(&likes, wg)
    go rapid_likes_sender2(&likes, wg)
    go rapid_likes_sender2(&likes, wg)
    i++
  }
  wg.Wait()
  print(likes)
}
```

This above is a go code to put this problem into perpective, even tho we are generating 10000 requests. We barely get the correct answer. This is a very solid introduction to race conditions and we'll discuss in short how we can avoid this. In some cases (in fortunate cases) we will only get inconsistent values, In most unfortunate situations this leads to a runtime error. With this I hope you are sold on channels, now let's look into using them.

- The basic syntax :

```go
  first_channel := make(chan string)
  first_channel <- "Hello, World!"
  our_message := <- first_channel
  //We have to use := for "our_message" as the variables needs to figure what it stored by itself, we can also declare its type manually
  fmt.Println(our_message)
```
<<<<<<< HEAD
So in the above code block, we see a channel that is happy to store strings, this is the same for any data type channels. But if you really did run the above code, you'll see we will get a runtime error :(. This is because we told our channel should store strings but did not mention how many, that is we have an unbuffered memory [We'll look into these shortly] . Let's fix that and look into `len` and `cap` functions of channels.
=======

So in the above code block, we see a channel that is happy to store strings, this is the same for any data type channels. But if you really did run the above code, you'll see we will get a runtime error :(. This is because we told our channel should store strings but did not mention how many. Let's fix that and look into `len` and `cap` functions of channels.
>>>>>>> ead23e9ddd114d689c5710289624bbf083ca1974

- Fixing channels :

```go
  first_channel := make(chan string,1)
  fmt.Println("Before queuing, len :",len(first_channel)) //Shows number of queued messages in the buffer
  fmt.Println("Before queuing, cap :",cap(first_channel)) //Shows the total capacity of buffer
  first_channel <- "Hello, World!"
  fmt.Println("After queuing one string, len :",len(first_channel))
  fmt.Println("After queuing one string, cap :",cap(first_channel))
  // first_channel <- "Second message :(" //Will cause runtime, is explained in blog.
  our_message := <- first_channel
  fmt.Println(our_message)
```

So in the above code, we see a lot going on. Let's break it down :

- We now have a channel size of 1, implying we can store one string in channel.
- the `len()` prints the number of "items" buffered.
- the `cap()` prints the max numbers of "items" that can be buffered.
  Do note, when ever the len() goes above cap() our code panic's in runtime.

* Using channels without buffering and tieing channels in with go routines:

```go
func recv_likes_and_sum(second_channel chan int, wg *sync.WaitGroup){
  likes := 0
  for{
    incoming_like, ok := <- second_channel
    if !ok{
      print(likes)
      wg.Done()
      return
    }
    likes+=incoming_like
  }
}

func rapid_like_sender(channel chan int, wg *sync.WaitGroup){
  i:=0
  for i<100{
    channel<-1
    i++
  }
  wg.Done() //Does -1 to wg

}

func routines_unbuf_channel(){
  second_channel := make(chan int) //Unbuffered
  wg := new(sync.WaitGroup)
  wg2 := new(sync.WaitGroup)
  wg.Add(1)
  go recv_likes_and_sum(second_channel,wg)
  wg2.Add(100)
  //We are basically sendinf 2 requests simulatneoulsy...the case that studied before.
  i:=1
  for i<=10{
    go rapid_like_sender(second_channel, wg2)
    go rapid_like_sender(second_channel, wg2)
    go rapid_like_sender(second_channel, wg2)
    go rapid_like_sender(second_channel, wg2)
    go rapid_like_sender(second_channel, wg2)
    go rapid_like_sender(second_channel, wg2)
    go rapid_like_sender(second_channel, wg2)
    go rapid_like_sender(second_channel, wg2)
    go rapid_like_sender(second_channel, wg2)
    go rapid_like_sender(second_channel, wg2)
    i++
  }
  wg2.Wait()
  close(second_channel)
  wg.Wait()
}
```

If you are sure if a channels always has an active recviever, we can let our channels be unbuffered! And the above example is accurate 100% of the time!! With that we come to an end of looking at channels and threads communication at quite the depth!

### The same example...just over engineered! [Speaker-3]

// Has to write code along

## 05-A very simple api - NetWork Module [Speaker-3]

## 06-What go can build! [N-Speakers]

## Refrences and Sources
